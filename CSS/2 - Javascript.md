



# JS

## 一、基础总结深入

### 知识线

数据类型 => 垃圾回收机制 => 事件

### 数据类型

#### 1 分类

##### 1.1 基本(值)类型

- `Number`
- `String`
- `Boolean`
- `undefined`
- `null`
- `Symbol`

##### # 1.2 对象(引用)类型

- `Object`：一般对象类型

- > `Array`：特别的对象类型(下标/内部数据有序)**(不够深入)**

  - 栈方法：`push()、pop()`

  - 队列方法：`push()`、`shift()`

  - 重排序方法：`reverse()`、`sort()`

  - 操作方法：

    - `concat()`：基于当前数组中的所有项创建一个新数组
    - `slice()`：基于当前数组的一或多个项创建一个新数组
    - `splice()`：插入、删除、替换操作

  - 位置方法：`indexOf()`、`lastIndexOf()`

  - - [ ] 迭代方法

    - `every()`
    - `filter()`
    - `forEach()`
    - `map()`
    - `some()`

  - - [ ] 归并方法

    - `reduce()`
    - `reduceRight()`

- `Function`：特别的对象类型(可执行)

- `Date`

- `RegExp`

#### 2 判断

##### 2.1 `typeof`

**可以区别**：数值、字符串、布尔值、undefined、function

**不能区别**：null与对象、一般对象与数组

```js
typeof undefined // 'undefined'
typeof '10'    // 'String'
typeof 10     // 'Number'
typeof false   // 'Boolean'
typeof Symbol()  // 'Symbol'
typeof Function  // ‘function'
typeof null // ‘Object’
typeof []     // 'Object'
typeof {}     // 'Object'
```

##### 2.2 `instanceof`

专门用来判断对象数据的类型：`Object`、`Array`、`Function`

`instanceof` 的原理是通过判断该对象的原型链中是否可以找到该构造函数的 `prototype` 属性

```js
function Foo(){}
var f1 = new Foo();
console.log(f1 instanceof Foo);// true
```

##### 2.3 `constructor`

对于引用类型，除此之外，还可以用 `xx.constructor.name` 构造函数来判断

```js
// constructor 构造来判断
console.log(fn.constructor.name)  // Function
console.log(date.constructor.name)// Date
console.log(arr.constructor.name) // Array
console.log(reg.constructor.name) // RegExp
```

##### 2.4 `Object.prototype.toString.call()`

一种最好的基本类型检测方式：`Object.prototype.toString.call({})`

可以区分所有的基本类型和所有的引用类型

#### 3 相关问题

> 1. undefined与null的区别?

* undefined代表变量没有赋值

* null: 代表变量赋值了, 只是值为null

> 2. 什么时候将变量赋值为null?

* 初始化赋值: 将要作为引用变量使用, 但对象还没有确定

* 结束时: 将变量指向的对象成为垃圾对象

> 3. 理解变量类型与数据类型?

* js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型

* 变量类型
  * 基本类型: 保存基本类型数据的变量
  * 引用类型: 保存对象地址值的变量

* 数据对象
  * 基本类型
  * 对象类型

### 垃圾回收机制

> 面试官：什么是内存泄漏？为什么会导致内存泄漏？

#### 1 什么是内存泄漏？

不再用到的内存，没有及时释放，就会形成内存泄漏。

#### 2 为什么会导致内存泄漏？

当我们**无法**再通过`js`代码来**引用到某个对象**，但**垃圾回收器**却认为这个对象还**在被引用**，因此在回收的时候**不会释放它**。导致了分配的这块**内存**永远也**无法被释放**出来，如果这样的情况越来越多，会导致**内存不够**用而系统崩溃。

#### 3 垃圾回收机制

> 面试官：说一说 JS 垃圾回收机制的运行机制的原理？
>

##### 3.1 标记清除

##### 3.2 引用计数























### 事件

> 事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。
>

#### 

#### 事件冒泡

==事件==开始时由==最具体==的元素接收，然后逐级向上传播到较为==不具体==的节点。

举个栗子：

我们的页面只写了一个 `div` 标签，那么我们点击它，`click` 事件会按照 `div>body>html>document` 的顺序传播。

也就是说，`div` 元素上会发生 `click` 事件，然后是 `body` 上会发生点击事件，然后是 `html` 元素，最后是 `documnet`。

（事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发）

##### 事件委托（事件冒泡的应用）

###### 是什么？

指将事件统一绑定给元素的共同祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。

###### 作用

利用了**冒泡**，减少事件**绑定次数**，提高程序的**性能**。

#### 事件捕获

事件捕获恰巧和事件冒泡相反，事件捕获的思想是==不太具体==的节点应该==更早==接收到事件，而==最具体==的节点应该==最后==接收到事件

上面的栗子中，换成事件捕获的话，那么 `document` 对象首先接收到事件，然后是 `html` 元素，然后是 `body` 元素，最后是 `div` 元素。 







## 二、函数高级

### 1. 原型与原型链

















### 2. 执行上下文与执行上下文栈

#### 2.1 变量提升与函数提升

1. 变量提升

* 通过var定义(声明)的变量, 在定义语句之前就可以访问到
* 值: undefined

2. 函数提升

* 通过function声明的函数, 在之前就可以直接调用
* 值: 函数定义(对象) 

#### 2.2 执行上下文

> 变量提升和函数提升是如何产生的？

1. 代码分类(位置)

* 全局代码

* 函数代码

2. 全局执行上下文

* 在执行全局代码前将window确定为全局执行上下文

* 对全局数据进行预处理

  * var定义的全局变量==>undefined, 添加为window的属性

  * function声明的全局函数==>**赋值(fun**), 添加为window的方法
  * this==>赋值(window)

* 开始执行全局代码

3. 函数执行上下文

* 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象

* 对局部数据进行预处理

  * 形参变量==>赋值(实参)==>添加为执行上下文的属性

  * arguments==>赋值(实参列表), 添加为执行上下文的属性

  * var定义的局部变量==>undefined, 添加为执行上下文的属性

  * function声明的函数 ==>赋值(fun), 添加为执行上下文的方法

  * this==>赋值(调用函数的对象)

* 开始执行函数体代码



### 3. 作用域与作用域链

### 4. 闭包





## 三、面向对象高级

### 1. 继承模式



## 四、线程机制与事件机制

## 五、数据处理

### 5.1 JSON

### 5.2 Ajax 与 跨域

### 5.3 存储

	- this
		- this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象
			1.以函数的形式调用时，this是window
			2.以方法的形式调用时，this是调用方法的对象
			3.以构造函数的形式调用时，this是新建的那个对象
			4.使用call和apply调用时，this是指定的那个对象
			5.在全局作用域中this代表window
- 构造函数的执行流程：(new 关键字的作用)
	1.创建一个新的对象
	2.将新的对象作为函数的上下文对象（this）
	3.执行函数中的代码
	4.将新建的对象返回









